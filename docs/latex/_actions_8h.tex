\doxysection{Actions.\+h File Reference}
\hypertarget{_actions_8h}{}\label{_actions_8h}\index{Actions.h@{Actions.h}}


Header file for the Actions module.  


{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$climits$>$}\newline
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$limits$>$}\newline
{\ttfamily \#include $<$random$>$}\newline
{\ttfamily \#include $<$cmath$>$}\newline
{\ttfamily \#include "{}graph.\+h"{}}\newline
{\ttfamily \#include $<$unordered\+\_\+map$>$}\newline
{\ttfamily \#include $<$queue$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_pair_hash}{Pair\+Hash}}
\begin{DoxyCompactList}\small\item\em Hash function for pairs used in memoization. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{_actions_8h_a5c8d45e169e35e5986354b3a63d2f610}\label{_actions_8h_a5c8d45e169e35e5986354b3a63d2f610} 
using {\bfseries Memoization\+Table} = std\+::unordered\+\_\+map$<$std\+::pair$<$\mbox{\hyperlink{class_vertex}{Vertex}}\texorpdfstring{$\ast$}{*}, int$>$, double, \mbox{\hyperlink{struct_pair_hash}{Pair\+Hash}}$>$
\item 
\Hypertarget{_actions_8h_a46660c16f5465560945c41519290f09e}\label{_actions_8h_a46660c16f5465560945c41519290f09e} 
using {\bfseries Matched\+Pairs} = std\+::vector$<$std\+::pair$<$\mbox{\hyperlink{class_vertex}{Vertex}}\texorpdfstring{$\ast$}{*}, \mbox{\hyperlink{class_vertex}{Vertex}}\texorpdfstring{$\ast$}{*}$>$$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \mbox{\hyperlink{_actions_8h_ac1d5fc2c93475767b5dd873f26a7df50}{TSPBacktracking}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Implements the backtracking algorithm to solve the TSP. The time complexity of this algorithm is O(n\texorpdfstring{$^\wedge$}{\string^}2 \texorpdfstring{$\ast$}{*} 2\texorpdfstring{$^\wedge$}{\string^}n). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_a0f0a1cb2c22a3fb8d03a11b494eddfc3}{TSPHeld\+Karp}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}curr, int bitmask, Memoization\+Table \&memoization)
\begin{DoxyCompactList}\small\item\em Recursive helper function for TSPBacktracking. The time complexity of this algorithm is O(n\texorpdfstring{$^\wedge$}{\string^}2 \texorpdfstring{$\ast$}{*} 2\texorpdfstring{$^\wedge$}{\string^}n). \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{_actions_8h_a5b4da6a2b11016fd064e0bcfa91afc4c}{prim\+MST}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, const std\+::string \&start\+Vertex\+Label)
\begin{DoxyCompactList}\small\item\em Generates a Minimum Spanning Tree (MST) using Prim\textquotesingle{}s algorithm. The time complexity of this algorithm is O((V + E) log V). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_actions_8h_a3db56f60b011fb3c2421d68a5d80d208}{pre\+Order\+Walk}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}vertex, std\+::unordered\+\_\+set$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&visited, std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&pre\+Order\+List)
\begin{DoxyCompactList}\small\item\em Performs a pre-\/order walk on the MST to generate a tour. The time complexity of this algorithm is O(V + E). \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_actions_8h_a67c5012286e810488418e5f5f2ab2a37}{connect\+All\+Edges}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Connects all edges in the graph based on the Haversine distance. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_ae046997a18d9027f005e938cd55937de}{TSPTriangular\+Approximation}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Solves the TSP using the Triangular Approximation heuristic. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2 log V). \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{_actions_8h_aa3d17ac49826349ff6b11c9ec328dab1}{find\+Perfect\+Matching}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}MST)
\begin{DoxyCompactList}\small\item\em Finds a perfect matching on the odd degree vertices of the MST. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{_actions_8h_a3783770d349c3beb8b8c6c50fe6e9386}{combine\+MSTAnd\+PM}} (const \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}MST, \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}MWPM)
\begin{DoxyCompactList}\small\item\em Combines the MST and minimum weight perfect matching to form a multigraph. The time complexity of this algorithm is O(V + E). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_a6102d9cd58af53b6404f32383bc42612}{find\+Eulerian\+Circuit}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}multigraph)
\begin{DoxyCompactList}\small\item\em Finds an Eulerian circuit in the given multigraph. The time complexity of this algorithm is O(V + E). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_a77597de03361f7c513e96b2aa9e4ead6}{shortcut\+Eulerian\+Circuit}} (const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&eulerian\+Circuit)
\begin{DoxyCompactList}\small\item\em Creates a Hamiltonian circuit by shortcutting the Eulerian circuit. The time complexity of this algorithm is O(\+V). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_aac2af149e343a6a07addc4b9c686b97a}{calculate\+Total\+Cost}} (const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&hamiltonian\+Circuit, \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Calculates the total cost of a given Hamiltonian circuit. The time complexity of this algorithm is O(\+V). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_a1d68d0148d233c525b2d19a4c855c2f9}{TSPChristofides}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Solves the TSP using Christofides\textquotesingle{} algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_a71958dc1dd4a1d37f077088b3a72f0b1}{nearest\+Neighbor\+TSP}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, const std\+::string \&start, double \&total\+Cost, int size, bool is\+FC)
\begin{DoxyCompactList}\small\item\em Solves the TSP using the Nearest Neighbor heuristic. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_a2245b7b1bc97ce746403db4b5c22afba}{NNTSP}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, const string \&start, double \&total\+Cost, vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&solution, int size, bool is\+FC)
\begin{DoxyCompactList}\small\item\em Solves the TSP using the Nearest Neighbor heuristic with a time limit. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_a48fb6db37840224b552684fc086f3bb3}{Simulated\+Annealing}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ solution, double \&total\+Cost, double initial\+Temp, double final\+Temp, double alpha, int max\+Iter)
\begin{DoxyCompactList}\small\item\em Solves the TSP using Simulated Annealing. The time complexity of this algorithm is O(k \texorpdfstring{$\ast$}{*} V\texorpdfstring{$^\wedge$}{\string^}2), where k is the number of iterations. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_actions_8h_a189ca605a8fb05330b41332e72f9250f}{floyd\+Warshall}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&shortest\+Paths)
\begin{DoxyCompactList}\small\item\em Runs the Floyd-\/\+Warshall algorithm to find shortest paths between all pairs of vertices. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_adb251236c733f1480f822c2aa9c18194}{find\+Odd\+Degree\+Vertices}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Finds vertices with odd degree in the graph. The time complexity of this algorithm is O(\+V). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_edge}{Edge}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_a0d6df4e9dca4e00364e9192e5cadbd81}{minimum\+Cost\+Perfect\+Matching}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}mst)
\begin{DoxyCompactList}\small\item\em Finds the minimum cost perfect matching among vertices with odd degree. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_graph}{Graph}} \mbox{\hyperlink{_actions_8h_a7cd4a7322fa3de69fe7a7e3b2bdd3d20}{combine\+MSTAnd\+MWPM}} (const \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}MST, const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&odd\+Degree\+Vertices, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&shortest\+Paths)
\begin{DoxyCompactList}\small\item\em Combines the MST and minimum weight perfect matching to form a multigraph. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_adc368fe41e770e2d0d33dcab86d086ee}{find\+Eulerian\+Walk}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}multigraph)
\begin{DoxyCompactList}\small\item\em Finds an Eulerian walk in the given multigraph. The time complexity of this algorithm is O(V + E). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_ad4567ea5fadfe7d570fb28e1a51ccadd}{substitute\+Shortest\+Path}} (const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&eulerian\+Circuit, \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&shortest\+Paths)
\begin{DoxyCompactList}\small\item\em Substitutes the shortest path for each edge in the Eulerian circuit. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{_actions_8h_a6d46cfc8cc6a68d51b1f93b4486efc58}{find\+Shortest\+Path}} (\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}start, \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}end, \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph)
\begin{DoxyCompactList}\small\item\em Finds the shortest path between two vertices in the graph. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). \end{DoxyCompactList}\item 
double \mbox{\hyperlink{_actions_8h_a87277d8561c171de0ae00327376e8162}{TSPExtended\+Christofides}} (\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}graph, const std\+::string \&start\+Vertex\+Label)
\begin{DoxyCompactList}\small\item\em Solves the TSP using an extended version of Christofides\textquotesingle{} algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\item 
Matched\+Pairs \mbox{\hyperlink{_actions_8h_a2df4a14a6c4b030c6a96d8820600d490}{hungarian\+Algorithm}} (const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&odd\+Degree\+Vertices, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&shortest\+Paths)
\begin{DoxyCompactList}\small\item\em Solves the minimum cost perfect matching problem using the Hungarian algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header file for the Actions module. 

This module contains the functions that implement the algorithms to solve the Traveling Salesman Problem (TSP). The algorithms implemented are\+:
\begin{DoxyItemize}
\item Backtracking
\item Held-\/\+Karp
\item Triangular Approximation
\item Christofides
\item Nearest Neighbor
\item Hybrid MST and Nearest Neighbor
\end{DoxyItemize}

The module also contains helper functions to generate Minimum Spanning Trees (MST), perfect matchings, and Eulerian circuits. 

\doxysubsection{Function Documentation}
\Hypertarget{_actions_8h_aac2af149e343a6a07addc4b9c686b97a}\label{_actions_8h_aac2af149e343a6a07addc4b9c686b97a} 
\index{Actions.h@{Actions.h}!calculateTotalCost@{calculateTotalCost}}
\index{calculateTotalCost@{calculateTotalCost}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{calculateTotalCost()}{calculateTotalCost()}}
{\footnotesize\ttfamily double calculate\+Total\+Cost (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{hamiltonian\+Circuit,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Calculates the total cost of a given Hamiltonian circuit. The time complexity of this algorithm is O(\+V). 


\begin{DoxyParams}{Parameters}
{\em hamiltonian\+Circuit} & Vector of vertices representing the Hamiltonian circuit. \\
\hline
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The total cost of the Hamiltonian circuit. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a7cd4a7322fa3de69fe7a7e3b2bdd3d20}\label{_actions_8h_a7cd4a7322fa3de69fe7a7e3b2bdd3d20} 
\index{Actions.h@{Actions.h}!combineMSTAndMWPM@{combineMSTAndMWPM}}
\index{combineMSTAndMWPM@{combineMSTAndMWPM}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{combineMSTAndMWPM()}{combineMSTAndMWPM()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_graph}{Graph}} combine\+MSTAnd\+MWPM (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{MST,  }\item[{const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{odd\+Degree\+Vertices,  }\item[{std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&}]{shortest\+Paths }\end{DoxyParamCaption})}



Combines the MST and minimum weight perfect matching to form a multigraph. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em MST} & Pointer to the MST graph. \\
\hline
{\em odd\+Degree\+Vertices} & Vector of vertices with odd degree. \\
\hline
{\em shortest\+Paths} & A map containing the shortest paths between vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Combined multigraph. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a3783770d349c3beb8b8c6c50fe6e9386}\label{_actions_8h_a3783770d349c3beb8b8c6c50fe6e9386} 
\index{Actions.h@{Actions.h}!combineMSTAndPM@{combineMSTAndPM}}
\index{combineMSTAndPM@{combineMSTAndPM}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{combineMSTAndPM()}{combineMSTAndPM()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_graph}{Graph}} combine\+MSTAnd\+PM (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{MST,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{MWPM }\end{DoxyParamCaption})}



Combines the MST and minimum weight perfect matching to form a multigraph. The time complexity of this algorithm is O(V + E). 


\begin{DoxyParams}{Parameters}
{\em MST} & Pointer to the MST graph. \\
\hline
{\em MWPM} & Pointer to the minimum weight perfect matching graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Combined multigraph. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a67c5012286e810488418e5f5f2ab2a37}\label{_actions_8h_a67c5012286e810488418e5f5f2ab2a37} 
\index{Actions.h@{Actions.h}!connectAllEdges@{connectAllEdges}}
\index{connectAllEdges@{connectAllEdges}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{connectAllEdges()}{connectAllEdges()}}
{\footnotesize\ttfamily void connect\+All\+Edges (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Connects all edges in the graph based on the Haversine distance. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\Hypertarget{_actions_8h_a6102d9cd58af53b6404f32383bc42612}\label{_actions_8h_a6102d9cd58af53b6404f32383bc42612} 
\index{Actions.h@{Actions.h}!findEulerianCircuit@{findEulerianCircuit}}
\index{findEulerianCircuit@{findEulerianCircuit}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{findEulerianCircuit()}{findEulerianCircuit()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ find\+Eulerian\+Circuit (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{multigraph }\end{DoxyParamCaption})}



Finds an Eulerian circuit in the given multigraph. The time complexity of this algorithm is O(V + E). 


\begin{DoxyParams}{Parameters}
{\em multigraph} & Pointer to the multigraph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the Eulerian circuit. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_adc368fe41e770e2d0d33dcab86d086ee}\label{_actions_8h_adc368fe41e770e2d0d33dcab86d086ee} 
\index{Actions.h@{Actions.h}!findEulerianWalk@{findEulerianWalk}}
\index{findEulerianWalk@{findEulerianWalk}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{findEulerianWalk()}{findEulerianWalk()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ find\+Eulerian\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{multigraph }\end{DoxyParamCaption})}



Finds an Eulerian walk in the given multigraph. The time complexity of this algorithm is O(V + E). 


\begin{DoxyParams}{Parameters}
{\em multigraph} & Pointer to the multigraph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the Eulerian walk. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_adb251236c733f1480f822c2aa9c18194}\label{_actions_8h_adb251236c733f1480f822c2aa9c18194} 
\index{Actions.h@{Actions.h}!findOddDegreeVertices@{findOddDegreeVertices}}
\index{findOddDegreeVertices@{findOddDegreeVertices}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{findOddDegreeVertices()}{findOddDegreeVertices()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ find\+Odd\+Degree\+Vertices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Finds vertices with odd degree in the graph. The time complexity of this algorithm is O(\+V). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices with odd degree. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_aa3d17ac49826349ff6b11c9ec328dab1}\label{_actions_8h_aa3d17ac49826349ff6b11c9ec328dab1} 
\index{Actions.h@{Actions.h}!findPerfectMatching@{findPerfectMatching}}
\index{findPerfectMatching@{findPerfectMatching}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{findPerfectMatching()}{findPerfectMatching()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_graph}{Graph}} find\+Perfect\+Matching (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{MST }\end{DoxyParamCaption})}



Finds a perfect matching on the odd degree vertices of the MST. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em MST} & Pointer to the MST graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxylink{class_graph}{Graph} representing the minimum weight perfect matching. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a6d46cfc8cc6a68d51b1f93b4486efc58}\label{_actions_8h_a6d46cfc8cc6a68d51b1f93b4486efc58} 
\index{Actions.h@{Actions.h}!findShortestPath@{findShortestPath}}
\index{findShortestPath@{findShortestPath}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{findShortestPath()}{findShortestPath()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ find\+Shortest\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{start,  }\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{end,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Finds the shortest path between two vertices in the graph. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em start} & Pointer to the starting vertex. \\
\hline
{\em end} & Pointer to the ending vertex. \\
\hline
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the shortest path. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a189ca605a8fb05330b41332e72f9250f}\label{_actions_8h_a189ca605a8fb05330b41332e72f9250f} 
\index{Actions.h@{Actions.h}!floydWarshall@{floydWarshall}}
\index{floydWarshall@{floydWarshall}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{floydWarshall()}{floydWarshall()}}
{\footnotesize\ttfamily void floyd\+Warshall (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&}]{shortest\+Paths }\end{DoxyParamCaption})}



Runs the Floyd-\/\+Warshall algorithm to find shortest paths between all pairs of vertices. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em shortest\+Paths} & A map to store the shortest paths. \\
\hline
\end{DoxyParams}
\Hypertarget{_actions_8h_a2df4a14a6c4b030c6a96d8820600d490}\label{_actions_8h_a2df4a14a6c4b030c6a96d8820600d490} 
\index{Actions.h@{Actions.h}!hungarianAlgorithm@{hungarianAlgorithm}}
\index{hungarianAlgorithm@{hungarianAlgorithm}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{hungarianAlgorithm()}{hungarianAlgorithm()}}
{\footnotesize\ttfamily Matched\+Pairs hungarian\+Algorithm (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{odd\+Degree\+Vertices,  }\item[{std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&}]{shortest\+Paths }\end{DoxyParamCaption})}



Solves the minimum cost perfect matching problem using the Hungarian algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em odd\+Degree\+Vertices} & Vector of vertices with odd degree. \\
\hline
{\em shortest\+Paths} & A map containing the shortest paths between vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of pairs representing the minimum cost perfect matching. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a0d6df4e9dca4e00364e9192e5cadbd81}\label{_actions_8h_a0d6df4e9dca4e00364e9192e5cadbd81} 
\index{Actions.h@{Actions.h}!minimumCostPerfectMatching@{minimumCostPerfectMatching}}
\index{minimumCostPerfectMatching@{minimumCostPerfectMatching}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{minimumCostPerfectMatching()}{minimumCostPerfectMatching()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_edge}{Edge}} \texorpdfstring{$\ast$}{*} $>$ minimum\+Cost\+Perfect\+Matching (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{mst }\end{DoxyParamCaption})}



Finds the minimum cost perfect matching among vertices with odd degree. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em mst} & Pointer to the MST graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of edges representing the minimum cost perfect matching. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a71958dc1dd4a1d37f077088b3a72f0b1}\label{_actions_8h_a71958dc1dd4a1d37f077088b3a72f0b1} 
\index{Actions.h@{Actions.h}!nearestNeighborTSP@{nearestNeighborTSP}}
\index{nearestNeighborTSP@{nearestNeighborTSP}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{nearestNeighborTSP()}{nearestNeighborTSP()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ nearest\+Neighbor\+TSP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{const std\+::string \&}]{start,  }\item[{double \&}]{total\+Cost,  }\item[{int}]{size,  }\item[{bool}]{is\+FC }\end{DoxyParamCaption})}



Solves the TSP using the Nearest Neighbor heuristic. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em start} & Label of the starting vertex. \\
\hline
{\em total\+Cost} & Reference to store the total cost of the tour. \\
\hline
{\em size} & Number of vertices in the graph. \\
\hline
{\em is\+FC} & Flag to indicate if the graph is fully connected. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the tour. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a2245b7b1bc97ce746403db4b5c22afba}\label{_actions_8h_a2245b7b1bc97ce746403db4b5c22afba} 
\index{Actions.h@{Actions.h}!NNTSP@{NNTSP}}
\index{NNTSP@{NNTSP}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{NNTSP()}{NNTSP()}}
{\footnotesize\ttfamily double NNTSP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{const string \&}]{start,  }\item[{double \&}]{total\+Cost,  }\item[{vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{solution,  }\item[{int}]{size,  }\item[{bool}]{is\+FC }\end{DoxyParamCaption})}



Solves the TSP using the Nearest Neighbor heuristic with a time limit. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em start} & Label of the starting vertex. \\
\hline
{\em total\+Cost} & Reference to store the total cost of the tour. \\
\hline
{\em size} & Number of vertices in the graph. \\
\hline
{\em is\+FC} & Flag to indicate if the graph is fully connected. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the tour. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a3db56f60b011fb3c2421d68a5d80d208}\label{_actions_8h_a3db56f60b011fb3c2421d68a5d80d208} 
\index{Actions.h@{Actions.h}!preOrderWalk@{preOrderWalk}}
\index{preOrderWalk@{preOrderWalk}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{preOrderWalk()}{preOrderWalk()}}
{\footnotesize\ttfamily void pre\+Order\+Walk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{vertex,  }\item[{std\+::unordered\+\_\+set$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{visited,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{pre\+Order\+List }\end{DoxyParamCaption})}



Performs a pre-\/order walk on the MST to generate a tour. The time complexity of this algorithm is O(V + E). 


\begin{DoxyParams}{Parameters}
{\em vertex} & Pointer to the current vertex. \\
\hline
{\em visited} & Set of visited vertices. \\
\hline
{\em pre\+Order\+List} & List to store the pre-\/order walk vertices. \\
\hline
\end{DoxyParams}
\Hypertarget{_actions_8h_a5b4da6a2b11016fd064e0bcfa91afc4c}\label{_actions_8h_a5b4da6a2b11016fd064e0bcfa91afc4c} 
\index{Actions.h@{Actions.h}!primMST@{primMST}}
\index{primMST@{primMST}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{primMST()}{primMST()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_graph}{Graph}} prim\+MST (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{const std\+::string \&}]{start\+Vertex\+Label }\end{DoxyParamCaption})}



Generates a Minimum Spanning Tree (MST) using Prim\textquotesingle{}s algorithm. The time complexity of this algorithm is O((V + E) log V). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em start\+Vertex\+Label} & Label of the starting vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The MST as a graph. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a77597de03361f7c513e96b2aa9e4ead6}\label{_actions_8h_a77597de03361f7c513e96b2aa9e4ead6} 
\index{Actions.h@{Actions.h}!shortcutEulerianCircuit@{shortcutEulerianCircuit}}
\index{shortcutEulerianCircuit@{shortcutEulerianCircuit}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{shortcutEulerianCircuit()}{shortcutEulerianCircuit()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ shortcut\+Eulerian\+Circuit (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{eulerian\+Circuit }\end{DoxyParamCaption})}



Creates a Hamiltonian circuit by shortcutting the Eulerian circuit. The time complexity of this algorithm is O(\+V). 


\begin{DoxyParams}{Parameters}
{\em eulerian\+Circuit} & Vector of vertices representing the Eulerian circuit. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the Hamiltonian circuit. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a48fb6db37840224b552684fc086f3bb3}\label{_actions_8h_a48fb6db37840224b552684fc086f3bb3} 
\index{Actions.h@{Actions.h}!SimulatedAnnealing@{SimulatedAnnealing}}
\index{SimulatedAnnealing@{SimulatedAnnealing}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{SimulatedAnnealing()}{SimulatedAnnealing()}}
{\footnotesize\ttfamily double Simulated\+Annealing (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$}]{solution,  }\item[{double \&}]{total\+Cost,  }\item[{double}]{initial\+Temp,  }\item[{double}]{final\+Temp,  }\item[{double}]{alpha,  }\item[{int}]{max\+Iter }\end{DoxyParamCaption})}



Solves the TSP using Simulated Annealing. The time complexity of this algorithm is O(k \texorpdfstring{$\ast$}{*} V\texorpdfstring{$^\wedge$}{\string^}2), where k is the number of iterations. 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em solution} & Initial solution as a vector of vertices. \\
\hline
{\em total\+Cost} & Reference to store the total cost of the tour. \\
\hline
{\em initial\+Temp} & Initial temperature for the annealing process. \\
\hline
{\em final\+Temp} & Final temperature for the annealing process. \\
\hline
{\em alpha} & Cooling rate. \\
\hline
{\em max\+Iter} & Maximum number of iterations. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum path cost found by the Simulated Annealing algorithm. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_ad4567ea5fadfe7d570fb28e1a51ccadd}\label{_actions_8h_ad4567ea5fadfe7d570fb28e1a51ccadd} 
\index{Actions.h@{Actions.h}!substituteShortestPath@{substituteShortestPath}}
\index{substituteShortestPath@{substituteShortestPath}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{substituteShortestPath()}{substituteShortestPath()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ substitute\+Shortest\+Path (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*} $>$ \&}]{eulerian\+Circuit,  }\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, std\+::unordered\+\_\+map$<$ \mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}, double $>$ $>$ \&}]{shortest\+Paths }\end{DoxyParamCaption})}



Substitutes the shortest path for each edge in the Eulerian circuit. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2). 


\begin{DoxyParams}{Parameters}
{\em eulerian\+Circuit} & Vector of vertices representing the Eulerian circuit. \\
\hline
{\em graph} & Pointer to the graph. \\
\hline
{\em shortest\+Paths} & A map containing the shortest paths between vertices. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Vector of vertices representing the Hamiltonian circuit. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_ac1d5fc2c93475767b5dd873f26a7df50}\label{_actions_8h_ac1d5fc2c93475767b5dd873f26a7df50} 
\index{Actions.h@{Actions.h}!TSPBacktracking@{TSPBacktracking}}
\index{TSPBacktracking@{TSPBacktracking}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{TSPBacktracking()}{TSPBacktracking()}}
{\footnotesize\ttfamily double TSPBacktracking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Implements the backtracking algorithm to solve the TSP. The time complexity of this algorithm is O(n\texorpdfstring{$^\wedge$}{\string^}2 \texorpdfstring{$\ast$}{*} 2\texorpdfstring{$^\wedge$}{\string^}n). 

This function initiates the TSP solution using a backtracking approach starting and ending at node "{}0"{}.


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph representing the nodes and edges. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum path cost calculated by the backtracking algorithm. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a1d68d0148d233c525b2d19a4c855c2f9}\label{_actions_8h_a1d68d0148d233c525b2d19a4c855c2f9} 
\index{Actions.h@{Actions.h}!TSPChristofides@{TSPChristofides}}
\index{TSPChristofides@{TSPChristofides}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{TSPChristofides()}{TSPChristofides()}}
{\footnotesize\ttfamily double TSPChristofides (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Solves the TSP using Christofides\textquotesingle{} algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The approximate minimum path cost. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a87277d8561c171de0ae00327376e8162}\label{_actions_8h_a87277d8561c171de0ae00327376e8162} 
\index{Actions.h@{Actions.h}!TSPExtendedChristofides@{TSPExtendedChristofides}}
\index{TSPExtendedChristofides@{TSPExtendedChristofides}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{TSPExtendedChristofides()}{TSPExtendedChristofides()}}
{\footnotesize\ttfamily double TSPExtended\+Christofides (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{const std\+::string \&}]{start\+Vertex\+Label }\end{DoxyParamCaption})}



Solves the TSP using an extended version of Christofides\textquotesingle{} algorithm. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}3). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em start\+Vertex\+Label} & Label of the starting vertex. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The approximate minimum path cost. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_a0f0a1cb2c22a3fb8d03a11b494eddfc3}\label{_actions_8h_a0f0a1cb2c22a3fb8d03a11b494eddfc3} 
\index{Actions.h@{Actions.h}!TSPHeldKarp@{TSPHeldKarp}}
\index{TSPHeldKarp@{TSPHeldKarp}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{TSPHeldKarp()}{TSPHeldKarp()}}
{\footnotesize\ttfamily double TSPHeld\+Karp (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph,  }\item[{\mbox{\hyperlink{class_vertex}{Vertex}} \texorpdfstring{$\ast$}{*}}]{curr,  }\item[{int}]{bitmask,  }\item[{Memoization\+Table \&}]{memoization }\end{DoxyParamCaption})}



Recursive helper function for TSPBacktracking. The time complexity of this algorithm is O(n\texorpdfstring{$^\wedge$}{\string^}2 \texorpdfstring{$\ast$}{*} 2\texorpdfstring{$^\wedge$}{\string^}n). 

Uses memoization to efficiently calculate the minimum path cost.


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
{\em curr} & Current vertex in the tour. \\
\hline
{\em bitmask} & Bitmask representing visited nodes. \\
\hline
{\em memoization} & Memoization table to store already computed costs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The minimum path cost from the current vertex. 
\end{DoxyReturn}
\Hypertarget{_actions_8h_ae046997a18d9027f005e938cd55937de}\label{_actions_8h_ae046997a18d9027f005e938cd55937de} 
\index{Actions.h@{Actions.h}!TSPTriangularApproximation@{TSPTriangularApproximation}}
\index{TSPTriangularApproximation@{TSPTriangularApproximation}!Actions.h@{Actions.h}}
\doxysubsubsection{\texorpdfstring{TSPTriangularApproximation()}{TSPTriangularApproximation()}}
{\footnotesize\ttfamily double TSPTriangular\+Approximation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_graph}{Graph}} \texorpdfstring{$\ast$}{*}}]{graph }\end{DoxyParamCaption})}



Solves the TSP using the Triangular Approximation heuristic. The time complexity of this algorithm is O(\+V\texorpdfstring{$^\wedge$}{\string^}2 log V). 


\begin{DoxyParams}{Parameters}
{\em graph} & Pointer to the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The approximate minimum path cost. 
\end{DoxyReturn}
